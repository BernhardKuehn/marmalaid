# artificial example
# ------------------- #
library(marmalaid)
fitness.func = MO.fitness.func.extraTrees.ranger
# run with RMSE-metric
metric.func.RMSE = RMSE
# change fitness function to probability == T
formals(fitness.func)$post.prob <- F
# define nr. of folds and permutations
formals(fitness.func)$folds <- 5
formals(fitness.func)$reps <- 30
formals(fitness.func)$return.scaled.metric = T
ga.input.RMSE = list(fitness.func = fitness.func,
metric.func = metric.func.RMSE)
# run NSGA-II feature selection with extraTrees model
NSGAII.feature.sel = NSGA.II_wrapper(
x,y,
seed = 12345,
ga.input = ga.input.RMSE,
mutation.rate = 1/ncol(x),
crossover.rate = 0.8,
remove.overlap = TRUE,
pop.size = 50,
offspring.size = 100,
max.iter = 20,
initialize.equal = TRUE,
stop.criterion = 10,
n.cores = 10,
ref.point = c(1,1)
)
# plot evolution
plot_NSGAII(NSGAII.feature.sel)
NSGAII.feature.sel$pareto.varnames
plot(x$X6)
plot(x$X6,type = "l")
cor(x$X6,predictors)
cor(x$X65,predictors)
# run NSGA-II feature selection with extraTrees model
NSGAII.feature.sel = NSGA.II_wrapper(
x,y,
seed = 12345,
ga.input = ga.input.RMSE,
mutation.rate = 1/ncol(x),
crossover.rate = 0.8,
remove.overlap = TRUE,
pop.size = 100,
offspring.size = 100,
max.iter = 20,
initialize.equal = TRUE,
stop.criterion = 10,
n.cores = 10,
ref.point = c(1,1)
)
# plot evolution
plot_NSGAII(NSGAII.feature.sel)
NSGAII.feature.sel$pareto.varnames
# run NSGA-II feature selection with extraTrees model
NSGAII.feature.sel = NSGA.II_wrapper(
x,y,
seed = 12345,
ga.input = ga.input.RMSE,
mutation.rate = 1/ncol(x),
crossover.rate = 0.8,
remove.overlap = TRUE,
pop.size = 100,
offspring.size = 100,
max.iter = 40,
initialize.equal = TRUE,
stop.criterion = 10,
n.cores = 10,
ref.point = c(1,1)
)
# plot evolution
plot_NSGAII(NSGAII.feature.sel)
NSGAII.feature.sel$pareto.varnames
NSGAII.feature.sel = NSGA.II_wrapper(
x,y,
seed = 12345,
ga.input = ga.input.RMSE,
mutation.rate = 0.1,
crossover.rate = 0.8,
remove.overlap = TRUE,
pop.size = 100,
offspring.size = 100,
max.iter = 40,
initialize.equal = TRUE,
stop.criterion = 10,
n.cores = 10,
ref.point = c(1,1)
)
# plot evolution
plot_NSGAII(NSGAII.feature.sel)
NSGAII.feature.sel$pareto.varnames
NSGAII.feature.sel$pareto.solution
NSGAII.feature.sel$pareto.solution -> a
NSGAII.feature.sel = NSGA.II_wrapper(
x,y,
seed = 12345,
ga.input = ga.input.RMSE,
mutation.rate = 1/ncol(x),
crossover.rate = 0.8,
remove.overlap = TRUE,
pop.size = 100,
offspring.size = 100,
max.iter = 40,
initialize.equal = TRUE,
stop.criterion = 10,
n.cores = 10,
ref.point = c(1,1)
)
# plot evolution
plot_NSGAII(NSGAII.feature.sel)
NSGAII.feature.sel$pareto.varnames
NSGAII.feature.sel$pareto.solution
a
# run NSGA-II feature selection with extraTrees model
NSGAII.feature.sel = NSGA.II_wrapper(
x,y,
seed = 12345,
ga.input = ga.input.RMSE,
mutation.rate = 0.1,
crossover.rate = 0.8,
remove.overlap = TRUE,
pop.size = 100,
offspring.size = 100,
max.iter = 150,
initialize.equal = TRUE,
stop.criterion = 50,
n.cores = 10,
ref.point = c(1,1)
)
# plot evolution
plot_NSGAII(NSGAII.feature.sel)
NSGAII.feature.sel$pareto.varnames
NSGAII.feature.sel$algorithm.params$time.taken
Model.metrics.regression_NSGAII(NSGAII.feature.sel,MO.fitness.func.extraTrees.ranger)
library(marmalaid)
?NSGA.II_wrapper
set.seed(12345)
N = 100
# create 4 predictors
AR1  = arima.sim(model = list(order = c(1,0,0),ar = 0.3),n = N)
ARMA1.1 = arima.sim(model = list(order = c(1,0,1),ar = 0.3,ma  = -0.5),n = N)
sine = sin(2*pi/(365)*1:N)
cosine = 0.5*cos(2*pi/(0.2*365)*1:N)
# combine to form the response
y = (1/(1+exp(-0.2*((1:N)-N/2)))-0.5) *0.6*AR1 +
+c((1:N-N/3)^2)/max(c((1:N-N/3)^2)) * 1*ARMA1.1 +
1:N/max(1:N) * 2*0.3 * sine * cosine +
rnorm(n = 100,mean = 0,sd = 0.4*min(sd(sine),sd(cosine)))
# plot
layout(mat = matrix(c(rep(1,8),2,2,3,3,4,4,5,5),ncol = 4,nrow = 4,byrow = T),
height = c(0.2,rep(0.3,4)))
par(mar = c(4,4,3,3))
plot(y,type = "l",main = "Response")
plot(AR1,type = "l",main = "AR1",xlab = "")
plot(ARMA1.1, type = "l",main = "ARMA1.1",xlab = "")
plot(sine,type = "l",main = "Sine",xlab = "")
plot(cosine,type = "l",main = "Cosine",xlab = "")
predictors = cbind(AR1,ARMA1.1,sine,cosine)
# create several correlated nonsense features with correlations ranging between 0.5 - 0.7
# taken from "https://stats.stackexchange.com/questions/15011/
# generate-a-random-variable-with-a-defined-correlation-to-an-existing-variables"
cors = runif(n = 100,min = 0.5,max = 0.7)*sample(c(1,-1),size = 100,replace = TRUE)
nonsenseVars = matrix(NA,ncol = 100,nrow = nrow(predictors))
for(i in seq(cors)){
rho   <- cors[i]               # desired correlation = cos(angle)
theta <- acos(rho)             # corresponding angle
x1    <- predictors[,sample(1:4,1,TRUE)]        # fixed given data
x2    <- rnorm(N, 0, sd(x1))      # new random data
X     <- cbind(x1, x2)         # matrix
Xctr  <- scale(X, center=TRUE, scale=FALSE)   # centered columns (mean 0)
Id   <- diag(N)                               # identity matrix
Q    <- qr.Q(qr(Xctr[ , 1, drop=FALSE]))      # QR-decomposition, just matrix Q
P    <- tcrossprod(Q)          # = Q Q'       # projection onto space defined by x1
x2o  <- (Id-P) %*% Xctr[ , 2]                 # x2ctr made orthogonal to x1ctr
Xc2  <- cbind(Xctr[ , 1], x2o)                # bind to matrix
Y    <- Xc2 %*% diag(1/sqrt(colSums(Xc2^2)))  # scale columns to length 1
nonsenseVars[,i] = Y[ , 2] + (1 / tan(theta)) * Y[ , 1]     # final new vector
}
# input data
x = data.frame(predictors,nonsenseVars)
cor(y,x)
barplot(cor(y,x))
par(mfrow = c(1,1))
barplot(cor(y,x))
cor(y,x)[order(abs(cor(y,x)))]
a = cor(y,x)[order(abs(cor(y,x)))]
cor(y,x)
a = cor(y,x)[order(abs(cor(y,x)),decreasing = T)]
a
a = cor(y,x)
a
b = a[order(abs(a),decreasing = T)]
b
b = names(a)[order(abs(a),decreasing = T)]
b
names(a)
names(a) = names(x)
b = names(a)[order(abs(a),decreasing = T)]
b
library(bounceR)
library(marmalaid)
?NSGA.II_wrapper
library(marmalaid)
?EOF.Monte.Carlo
library(marmalaid)
?EOF.Monte.Carlo
library(marmalaid)
# Weihnachtsfeier
phanto = read.table("C:/Users/kuehn/Documents/Weihnachtsfeier2020_Phantomime_Begriffe.csv",header = T,sep = ",")
View(phanto)
# Weihnachtsfeier
phanto = read.table("C:/Users/kuehn/Documents/Weihnachtsfeier2020_Phantomime_Begriffe.csv",header = T,sep = ";")
phanto
set.seed(12345)
phanto$Begriffe[sample(phanto$Index,size = nrow(phanto),replace = F)]
set.seed(12345)
phanto$Begriffe[sample(phanto$Index,size = nrow(phanto),replace = F)]
set.seed(12345)
phanto$Begriffe[sample(phanto$Index,size = nrow(phanto),replace = F)]
library(marmalaid)
?calc.lags
?calc.mean.over.Month
?EOF.Monte.Carlo
?fieldAnomaly.raster
?fitnessfuns
?MAE
?MO.fitness.func.RF.regression
?MO.fitness.func.RF.ranger
MO.fitness.func.RF.ranger
MO.fitness.func.RF.regression
?Model.metrics.regression_NSGAII
?mult.merge
?marmalaid::NSGA.II_wrapper
?marmalaid::plot_NSGAII
?marmalaid::salt.ahoi
?marmalaid::spatial.PCA
?marmalaid::spatial.SOM
?marmalaid::SOM.quant.error
load("J:/Corona HomeOffice/ml-in-sr-research/results/Feat.sel.with.package.RData")
Feat.sel.with.package$algorithm.params
Feat.sel.with.package$pareto.solution
library(sinkr)
library(marmalaid)
?fieldAnomaly.raster
?fieldAnomaly
as.POSIXlt("2020-02-29")$yday
format(as.Date("2020-02-29"),"%m%d")
as.POSIXlt("2020-02-29")$yday
strftime(as.Date("2020-02-29"),"%j")
strftime(as.Date("2020-02-29"),"doy")
?fieldAnomaly.raster
View(fieldAnomaly())
View(fieldAnomaly#
)
warnings()
library(marmalaid)
?fieldAnomaly.raster
library(marmalaid)
fieldAnomaly.raster
?fieldAnomaly.raster
?fieldAnomaly
library(marmalaid)
?fieldAnomaly.raster
library(marmalaid)
?SOM.qualityMetrics
?SOM.qualityMetrics
library(marmalaid)
?SOM.qualityMetrics
library(marmalaid)
?SOM.qualityMetrics
library(marmalaid)
?SOM.qualityMetrics
?calc.lags
?EOF.Monte.Carlo
?Model.metrics.regression_NSGAII
?NSGA.II_wrapper
?plot_NSGAII
?SOM.qualityMetrics
?SOM.qualityMetrics
library(marmalaid)
library(marmalaid)
#' @references
#'    Kiviluoto K (1996) "Topology preservation in self-organizing maps." In: Proceedings of International Conference on Neural Networks (ICNN’96). IEEE, p 294–299
#'    \cr \cr
#'    Kaski S, Lagus K (1996) "Comparing self-organizing maps." In: von der Malsburg C , von Seelen W , Vorbrüggen JC, Sendhoff B (eds) Artificial Neural Networks — ICANN 96. ICANN 1996. Lecture Notes in Computer Science, vol 1112. Springer, Berlin, Heidelberg.p 809–814
#'    \cr \cr
#'    Pötzlbauer G (2004) "Survey and comparison of quality measures for self-organising maps." In: Proc. 5th Workshop on Data Analysis (WDA 2004).p 67–82
#'
#'
#' @rdname SOM.qualityMetrics
#' @export
SOM.quant.error = function(SOM.obj){
# mean of the distances of the fitted SOM-obj.
QE = sum(SOM.obj$distances)/length(SOM.obj$distances)
return(QE)
}
#' @rdname SOM.qualityMetrics
#' @export
SOM.topo.error = function(SOM.obj){
# data
data = SOM.obj$data[[1]]
# pattern the data was mapped to
pattern = SOM.obj$codes[[1]]
# distance of data to the BMUs
data.to.Nodes = data.frame(BMU = rep(NA,nrow(data)),
SNDMU = rep(NA,nrow(data)),
C.index = rep(NA,nrow(data)))
for(i in 1:nrow(data)){
dp = data[i,]
dist.dp = rep(NA,nrow(pattern))
# calculate distance of each data point to each Node
for(j in 1:nrow(pattern)){
mat = rbind(dp,pattern[j,])
dist.dp[j] = stats::dist(mat)
}
# calculate best and second best matching pattern and distance to best
best.mu = which(dist.dp == min(dist.dp))
d.bmu.x = dist.dp[best.mu]
dist.dp[best.mu] = NA
snd.mu = which(dist.dp == min(dist.dp,na.rm = TRUE))
# if distance to two or more nodes is equal take the first one
if(length(snd.mu)>1){
snd.mu = snd.mu[1]
}
# calculate distance between best and second best matching unit
dist.mat.BMU = as.matrix(stats::dist(pattern,upper = TRUE,diag = TRUE)) # object.distances(SOM.obj,type = "codes")
d.bmu.sndmu = dist.mat.BMU[best.mu,snd.mu]
# calculate combined index
C.index = d.bmu.x + d.bmu.sndmu
# write in data.frame
data.to.Nodes[i,"BMU"] = best.mu
data.to.Nodes[i,"SNDMU"] = snd.mu
data.to.Nodes[i,"C.index"]  = C.index
}
# distance between BMUs on the grid
dists.2D = kohonen::unit.distances(SOM.obj$grid, toroidal = SOM.obj$grid$toroidal)
# check if BMU & SNDMU are neighbours
data.to.Nodes$neighbours = apply(data.to.Nodes,1,function(x) ifelse(dists.2D[x[1],x[2]] <= 1,0,1))
# calculate topographic error
TE = sum(data.to.Nodes$neighbours)/nrow(data.to.Nodes)
# Calculate mean C-index over all nodes
C.index.mean = mean(data.to.Nodes$C.index)
return(list(TE = TE,
C.index = C.index.mean,
Mapping.of.data =  data.to.Nodes))
}
?SOM.qualityMetrics
library(marmalaid)
?MO.fitness.func.extraTrees.ranger
?EOF.Monte.Carlo
?MAE
library(marmalaid)
?MAE
library(marmalaid)
calc.lags(1:10,-1)
calc.lags(1:10,-2)
calc.lags(1:10,-2:3)
class(calc.lags(1:10,-2:3))
?fieldAnomaly.raster
library(marmalaid)
library(marmalaid)
library(marmalaid)
?metricfuns
?metricfuns
library(marmalaid)
library(marmalaid)
?metricfuns
?metricfuns
library(marmalaid)
library(marmalaid)
?metricfuns
library(marmalaid)
library(marmalaid)
library(marmalaid)
library(marmalaid)
?fitnessfuns
library(marmalaid)
?fitnessfuns
library(marmalaid)
library(marmalaid)
citation("marmalaid")
vignette("marmalaid")
library(marmalaid)
?marmalaid
??marmalaid
devtools::build_manual()
build()
library(devtools)
build()
build_manual()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
data("sst.ahoi")
fieldAnomaly.to.original = function(rst1,time,level = "month"){
# rst1 needs to have the dim(lat,long,times)
if((class(rst1) != "RasterBrick"| class(rst1) != "SpatRaster") & length(dim(rst1)) != 3) {
stop("Input data 'rst1' is not of class 'Rasterbrick' or 'SpatRaster'!")
}
# get the means
means = attributes(rst1)$grid.means
# back-calculate
if(class(rst1) == "RasterBrick"){
mat.anom = t(raster::as.matrix(rst1)) # rows = temporal dimension # cols = spatial dimension
} else if(class(rst1) == "SpatRaster"){
mat.anom = t(terra::as.matrix(rst1))
}
if(length(time) != nrow(mat.anom)) {
stop(paste("Supplied time vector needs to be the same length as 3rd dim. in the raster rst1!",
"\n 3rd dim raster:",nrow(mat),"\n length time:", length(time)))
}
#based on function from sinkr-pkg
if (level == "month") {
levs <- as.POSIXlt(time)$mon
ulevs <- sort(unique(levs))
levs_lookup <- lapply(ulevs, function(x, y) which(y == x), levs)
names(levs_lookup) <- ulevs
}
if (level == "julian") {
levs <- as.POSIXlt(time)$yday
ulevs <- sort(unique(levs))
levs_lookup <- lapply(ulevs, function(x, y) which(y == x), levs)
names(levs_lookup) <- ulevs
}
if (level == "day") {
levs <- format(time, format = "%m%d")
ulevs <- sort(unique(levs))
levs_lookup <- lapply(ulevs, function(x, y) which(y == x), levs)
names(levs_lookup) <- ulevs
}
mat <- mat.anom * NaN
for (j in seq(levs_lookup)) {
mat[levs_lookup[[j]], ] <- t(t(as.matrix(mat.anom[levs_lookup[[j]],
])) + means[,j])
}
if(class(rst1) == "RasterBrick"){
original = raster::rasterFromXYZ(data.frame(raster::xyFromCell(rst1,cell = 1:raster::ncell(rst1)),t(mat)))
# crs
raster::crs(original) = raster::crs(rst1)
} else if(class(rst1) == "SpatRaster"){
original = terra::rast(data.frame(terra::xyFromCell(rst1,cell = 1:raster::ncell(rst1)),t(mat)),
type = "xyz",crs = terra::crs(rst1))
}
return(original)
}
time.ahoi = as.Date(sub("X","",names(sst.ahoi)),format = "%Y.%m.%d")
sst.anom = fieldAnomaly.raster(sst.ahoi,
time = )
sst.anom = fieldAnomaly.raster(sst.ahoi,
time = time.ahoi)
# back calculate
fieldAnomaly.to.original(sst.anom,time = time.ahoi)
# back calculate
original.field = fieldAnomaly.to.original(sst.anom,time = time.ahoi)
library(raster)
plot(cellStats(original.field,mean),type= "l")
lines(cellStats(sst.anom,mean),col= "red")
lines(cellStats(sst.ahoi,mean),col= "red")
cellStats(sst.ahoi,mean)
cellStats(original.field,mean)
# check if they are the same
all(cellStats(original.field,mean) -cellStats(sst.ahoi,mean)== 0)
time.ahoi = as.Date(sub("X","",names(sst.ahoi)),format = "%Y.%m.%d")
sst.anom = fieldAnomaly.raster(sst.ahoi,
time = time.ahoi,
level = "day")
# back calculate
original.field = fieldAnomaly.to.original(sst.anom,time = time.ahoi)
# check if they are the same
all(cellStats(original.field,mean) -cellStats(sst.ahoi,mean)== 0)
original.field
sst.anom
sst.anom = fieldAnomaly.raster(sst.ahoi,
time = time.ahoi,
level = "julian")
sst.anom
plot(cellStats(sst.anom,mean),type = "l")
# back calculate
original.field = fieldAnomaly.to.original(sst.anom,time = time.ahoi)
# check if they are the same
all(cellStats(original.field,mean) -cellStats(sst.ahoi,mean)== 0)
# back calculate
original.field = fieldAnomaly.to.original(sst.anom,time = time.ahoi,level = "julian")
# check if they are the same
all(cellStats(original.field,mean) -cellStats(sst.ahoi,mean)== 0)
devtools::check()
devtools::build_manual()
devtools::build()
devtools::build_manual(path = "./manual/")
devtools::check()
`rm(list = c("fieldAnomaly.to.original"))
)
)
""
))
1
a = 1
fkecweü
33
""
